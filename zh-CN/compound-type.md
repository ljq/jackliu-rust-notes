### compound-type

#### 切片(slice)

转换方式：取引用，**此用法是基于```deref```隐式强制转换**
```
String::from("hello,world")
"hello,world".to_string()
```

String 可变，而字符串字面值str不可变的考量：
* String 类型，为了支持一个可变、可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容，这些都是在程序运行时完成的。首先向操作系统请求内存来存放 String 对象(由 ```String::from()``` 完成),创建了一个全新的 String。
字符串变量在使用完成后，将内存释放，归还给操作系统，此设计的考量：  
Rust基于安全和性能的考虑，同时避免手动管理内存和引入GC机制，采用的方案：变量在离开作用域后，就自动释放其占用的内存。
* ```&str``` 与 ```String``` 之间的关系：```&str```长度固定的字符串切片，```String```是可动态增长的字符串，两者都是 Rust 的高级类型：集合类型。

变量内存释放的基本过程：
* Rust释放内存的函数：drop()，Rust 则在变量离开作用域时，**自动调用 drop() 即时释放内存**:
* 此模式类似C++的RAII概念: Resource Acquisition Is Initialization (RAII)；




#### 元祖（tuple）

* 元祖访问：```.```的访问方式，元组的索引从 ```0``` 开始
* 元祖解构：模式匹配解构元组：
```
let tup = (1, 2, 3);
let (x, y, z) = tup;
```

##### 结构体(struct)

struct初始化(以User结构体为例):
* 初始化实例每个字段都需要进行初始化
* 初始化时的字段顺序无顺序绑定
* 结构体初始化声明：
```
let mut user = User {
    name: "1"
}
```
* 结构体创建字段简化：
当函数参数和结构体字段同名时，可以直接使用缩略的方式进行初始化（类似TypeScript）
```
/*User {
    username: username,
    email: email
}*/
User {
    username,
    email
}
```
* 结构体更新：
```
 let user2 = User {
        username: "",
        ...user1
    };
```
**注意事项：...只支持在尾部使用**

**struct赋值注意事项：**
结构体实例字段值修改的前提是声明```mut```为可变，Rust 结构体内部字段不可单独标记为可变。

结构体的组织形式：
* 元组结构体(Tuple Struct)：结构体的字段可以匿名，类似元祖，故称元组结构体。```struct User(i32, i32, i32);```
* 单元结构体(Unit-like Struct): **定义一个只关心行为无需关心类型的内容类型时**，就可以使用单元结构体。```struct user```（无{ }）


打印struct结构体信息(```#[derive(Debug)]```标记显示)
* 打印方式:
```
println!("rect1 is {:?}", rect1);
```
* Rust未实现默认显示(Display)特征，这是因为如果我们使用 {} 来格式化输出，那对应的类型就必须实现 Display 特征。  
    **Rust不实现默认显示（Display）的特征原因**：由于struct结构体本身输出格式的复杂性，Rust不希望猜测开发者想要打印什么格式输出，把选择权交给开发者自己实现。实现结构体打印提供两种方式：
    * 传统手动指定字段实现
    * 使用 derive 派生实现（显示打印输出结构体的方式） 
    文件头添加派生特征标记(派生特征trait)
    ```
    #[derive(Debug)]
    ```
    * 格式化可读性输出方式：```{:#?} 来替代 {:?}```
* 输出 debug 信息的另一种方式：```dbg!``` 宏： 
    原理：它会拿走表达式的所有权，然后打印出相应的**文件名、行号**等 Debug 信息.除此之外，最终把表达式值的所有权返回！
* ```dbg!``` 宏和```println!```宏之间的注意事项：  
    * ```dbg!```输出到标准错误输出 stderr
    * ```println!``` 输出到标准输出 stdout

#### 枚举（enum）

```
enum user { }
```

* 枚举的重要使用场景：
**Option枚举处理空值None(非null)**:
Rust设计时抛弃传统 null 值定义，改用 Option 枚举变量来表达。
Option的类型：
```
// 其中 T 是泛型
enum Option<T> {
    Some(T),
    None,
}
```
备注：Rust 标准库```prelude```已引入此枚举类型，无须显式引入作用域。

语法：
```
let num = Some(5);
let str = Some("a string");
let opt: Option<i32> = None;
// Some值：值保存在 Some 中
// None值，无效空值
```
注意事项：如果使用None，必须显示声明类型，否则编译器只通过 None 值无法推断出 Some 值的类型。
设计的考量：
Rust采用此方案原因：
* 限制空值的泛滥
* 如果值非Option<T>类型，编译器可以安全的认定它的值不为空



#### 数组(Array)

* 数组（array）：存储在栈上速度快，array三要素（长度固定、类型相同、依次线性排列）
* 动态数组（vector）：存储在堆上，性能损耗(相对于array),可动态改变
* array 和 vector 都是 Rust 的高级类型：集合类型。
类型声明方式：
```
// [类型；长度]
let a: [i32; 5] = [1, 2, 3, 4, 5];
```
简化方式：
```
let a = ["a", "b"]
```
重复值简化声明方式（不推荐）：
```
let a = [3; 5]; // [3, 3, 3, 3, 3];
```

#### 数组切片（Array Slice）

语法：
```
let a: [i32; 5] = [1, 2, 3, 4, 5];
let slice: &[i32] = &a[1..3];
assert_eq!(slice, &[2, 3]);

```
语法糖**0..a.len**：其实就等于一个数组，元素是从0,1,2一直增加到到a.len-1

切片的特性：
* 切片长度非固定
* 切片创建开销小，是底层数组的引用
* 切片类型[T]本身非固定大小，切片引用类型&[T]具有固定的大小，因此&[T]更有用,&str字符串切片类似

注意事项：
* 数组类型(```[T;n]```)和数组切片(```[T]```)区别：**切片是运行期的数据结构长度无法在编译期得知**，所以长度不定
* **数组的长度也是类型的一部分**，所以[u8; 3]和[u8; 4]是不同的类型
* 数组切片[T]常用的方式是通过引用的方式去使用&[T]，&[T]切片引用类型具有固定大小















