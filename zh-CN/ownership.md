### 所有权(ownership)

#### 计算机语言内存管理三大主流(Memory Management)

* 垃圾回收机制(GC)：  
在程序运行时不断寻找不再使用的内存，典型代表：golang和java;

* 手动管理机制：  
手动操作内存的分配和释放, 在语言层面通过函数调用的方式来申请和释放内存，典型代表：C和C++;

* 所有权管理机制(ownership)：  
通过所有权机制来管理内存，编译器在编译时会根据一系列规则进行编译期期相对严格的检查，同时规避运行时过多的内存检查;

#### Rust选择所有权机制的原因

* 内存安全：通过职责明确的内存管理，避免内存抢占和共享等可能带来的不确定性，相对更安全；

* 运行性能：检查只发生在编译期，因此对于程序运行期，不会有任何性能上的损失；内存创建、分配和回收上更高效，无需其他传统GC语言的计数淘汰机制。

#### 所有权三原则

* Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者
* 一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者
* 当所有者(变量)离开作用域范围时，这个值将被丢弃(drop)

#### 引用与借用

###### 引用：允许使用值但不获取其所有权，数据指针

###### 借用：将获取引用作为函数参数称为 借用（borrowing），是一种行为，不仅限于变量形参的引用，常见于函数参数获取

* 引用：\& 引用，允许你使用值，但是不获取所有权。指针类型，指向对象存储的内存地址
* 解引用: \*号解引用
* 数值与引用之间类型不同，故不可直接进行比较
* 变量引用分为**可变引用**和**不可变引用**，函数中使用```&```或```&mut```区分
* 不可变引用限制：同一作用域，特定数据只允许一个可变引用，限制的原因是在编译期避免数据竞争带来的潜在问题  
    【数据竞争】常见行为：
    * 多指针同时访问同一数据
    * 至少一个指针被用来写入数据
    * 无同步数据访问的机制
* 同一作用域下同一变量**可变引用**与**不可变引用**不能同时存在，此设计的目的是：避免变量在引用或借用期间被改变可变性导致数据污染。

#### 悬垂引用（Dangling References）

###### 悬垂引用：指针还存在，但是指针指向的内存已经被释放。Rust编译器确保指针永远不会变为悬垂状态。

###### 引用的基本原则

* 在任意给定时间，要么**只能有一个可变引用**，要么**只能有多个不可变引用**。
* 引用必须总是有效。
